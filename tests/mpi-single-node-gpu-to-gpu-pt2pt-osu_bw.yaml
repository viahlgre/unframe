name: osu-gpu-gcd2gcd-bw
tags: [gpu, mpi, single-node, bandwidth]
description: OSU GCD-to-GCD pt2pt

params:
  rank0_gcd: [0, 1]
  rank1_gcd: [0, 1, 2, 3, 4, 5, 6, 7]
  transfer_size: [1048576, 67108864]

command:
  - srun
  - --mpi=pmi2
  - --gpus-per-node 8
  - --ntasks 2
  - --nodes 1
  - --partition {{ extra_args.partition }}
  - --account {{ extra_args.account }}
  - singularity
  - run
  - -B /boot/config-5.14.21-150500.55.49_13.0.56-cray_shasta_c
  - -B /pfs/lustrep3/users/viahlgre
  - "{{ extra_args.sif }}"
  - bash -c
  - "{{ snippet.script }}"

snippets:
  - name: script
    content: |
      if [[ $PMI_RANK -eq 0 ]]; then
        export ROCR_VISIBLE_DEVICES=${rank0_gcd};
      elif [[ $PMI_RANK -eq 1 ]]; then
        export ROCR_VISIBLE_DEVICES={{ rank1_gcd }};
      else
        echo "unexpected rank $PMI_RANK" >&2; exit 1;
      fi
      /usr/libexec/osu-micro-benchmarks/mpi/pt2pt/osu_bw -m ${transfer_size}:${transfer_size} D D

# Result parsing function parses stdout from the command and retuns anything
# the corresponding validate function can parse: parse(text, params) -> any type
parse: |
  def parse(text, params):
      import re
      # last float in output = bandwidth MB/s (OSU format)
      bw = None
      for line in reversed(text.splitlines()):
          m = re.search(r"([0-9]+\.[0-9]+)", line)
          if m:
              bw = float(m.group(1))
              break
      # include the params in the results so validate can reason on them
      return {
          "rank0_gcd": params["rank0_gcd"],
          "rank1_gcd": params["rank1_gcd"],
          "transfer_size": params["transfer_size"],
          "bandwidth_MBps": bw,
      }

# Validate function validates anything the corresponding parse function produces.
# validate(results, params) -> bool OR (bool, message)
validate: |
  def validate(results, params):
      a = params["rank0_gcd"]
      b = params["rank1_gcd"]
      sz = params["transfer_size"]
      bw = results.get("bandwidth_MBps")
      key = (a, b, sz)

      if bw is None:
          return (False, "no bandwidth parsed")

      expected_minimums = {
          (0,0,67108864): 480000,
          (0,1,67108864): 50000,
          (0,2,67108864): 37000,
          (0,3,67108864): 37000,
          (0,4,67108864): 37000,
          (0,5,67108864): 37000,
          (0,6,67108864): 50000,
          (0,7,67108864): 37000,
          
          (1,0,67108864): 50000,
          (1,1,67108864): 480000,
          (1,2,67108864): 37000,
          (1,3,67108864): 37000,
          (1,4,67108864): 37000,
          (1,5,67108864): 37000,
          (1,6,67108864): 50000,
          (1,7,67108864): 37000,
          
          (0,0,1048576): 50000,
          (0,1,1048576): 36000,
          (0,2,1048576): 25000,
          (0,3,1048576): 25000,
          (0,4,1048576): 25000,
          (0,5,1048576): 25000,
          (0,6,1048576): 25000,
          (0,7,1048576): 25000,
          
          (1,0,1048576): 36000,
          (1,1,1048576): 50000,
          (1,2,1048576): 25000,
          (1,3,1048576): 25000,
          (1,4,1048576): 25000,
          (1,5,1048576): 25000,
          (1,6,1048576): 25000,
          (1,7,1048576): 25000,
      }

      threshold = expected_minimums.get(key)

      ok = bw >= threshold
      msg = "min={} MB/s, got {:.1f} MB/s".format(threshold, bw)
      return (ok, msg)
